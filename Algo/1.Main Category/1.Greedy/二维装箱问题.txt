贪心策略
二维装箱问题
http://fusion.grids.cn/mzhang/shixi/AMC2Solution.pdf
http://poj.org/showmessage?message_id=170840


大致题意：
一个工厂制造的产品形状都是长方体盒子，它们的高度都是 h，长和宽都相等，一共有六个型号，分别为1*1, 2*2, 3*3, 4*4, 5*5, 6*6。
这些产品通常使用一个 6*6*h 的长方体箱子包装然后邮寄给客户。因为邮费很贵，所以工厂要想方设法的减小每个订单运送时的箱子数量BoxNum。
 
解题思路：
由于盒子和箱子的高均为h，因此只需考虑底面积的空间。
 
6*6的盒子，每个盒子独占一个箱子。
5*5的盒子，每个盒子放入一个箱子，该箱子的剩余空间允许放入的最大尺寸为1*1，且最多放11个。
4*4的盒子，每个盒子放入一个箱子，该箱子的剩余空间允许放入的最大尺寸为2*2。
3*3的盒子，每4个刚好独占一个箱子，不足4个3*3的，剩下空间由2*2和1*2填充。
2*2的盒子和1*1的盒子主要用于填充其他箱子的剩余空间，填充后的多余部分才开辟新箱子装填。

算法思路

这是一道纯模拟题，按一般思路就可以构造出通解程序。

由于产品和包裹的高度都是H，所以只需要考虑平面上正方形的摆放方式；
对于[6*6]、[5*5]、[4*4]的产品，每个包裹只能容纳一个这样的产品，所以箱子的数目至少有这类的产品个数的总和；
对于装有[6*6]产品的包裹，已经没有额外的空间可以装其它产品；
对于装有[5*5]产品的包裹，至少还可以装下11个[1*1]的产品；
对于装有[4*4]产品的包裹，至少还可以装下5个[2*2]的产品（或每个[2*2]的产品等价为4个[1*1]产品）；
一个新的包裹至少可以放得下4个[3*3]的产品，如果有剩于空间，可分为三种情况：
剩3个[3*3]的产品的空间，可以放下5个[2*2]与7个[1*1]的产品；
剩2个[3*3]的产品的空间，可以放下3个[2*2]与6个[1*1]的产品；
剩1个[3*3]的产品的空间，可以放下1个[2*2]与5个[1*1]的产品；
如果还有空间，可用[1*1]的产品填充；
一个新的包裹至少可以放得下9个[2*2]的产品，如果有剩于空间，可用[1*1]的产品填充；
一个新的包裹至少可以放得下36个[1*1]的产品；
统计所有的箱子数。

//Memory Time 
//248K   32MS 

#include<iostream>
using namespace std;

int max(int a,int b)
{
	return a>b?a:b;
}

int main(void)
{
	int s1,s2,s3,s4,s5,s6;      //6种size的盒子数量
	while(cin>>s1>>s2>>s3>>s4>>s5>>s6 && (s1+s2+s3+s4+s5+s6))
	{
		int BoxNum=0;           //放进所有盒子所需的最少箱子数

		BoxNum+=s6;             //6*6的盒子，每个都刚好独占一个箱子

		BoxNum+=s5;             //5*5的盒子，放进箱子后，每个箱子余下的空间只能放11个1*1的盒子
		s1=max(0,s1-s5*11);     //把1*1的盒子尽可能地放进已放有一个5*5盒子的箱子

		BoxNum+=s4;             //4*4的盒子，放进箱子后，每个箱子余下的空间为5个2*2的盒子空间
		                        //先把所有2*2的盒子尽可能地放进这些空间
		if(s2>=s4*5)             //若2*2的盒子数比空间多
			s2-=s4*5;           //则消去已放进空间的部分
		else                    //若2*2的盒子数比空间少
		{                       //则先把所有2*2的盒子放进这些空间
			s1=max(0,s1-4*(s4*5-s2));   //再用1*1的盒子填充本应放2*2盒子的空间
			s2=0;               //一个2*2空间可放4个1*1盒子
		}

		BoxNum+=(s3+3)/4;       //每4个3*3的盒子完全独占一个箱子
		s3%=4;            //3*3的盒子不足4个时，都放入一个箱子，剩余空间先放2*2，再放1*1
		if(s3)
		{                       //当箱子放了i个3*3盒子，剩下的空间最多放j个2*2盒子
			if(s2>=7-2*s3)       //其中i={1,2,3} ; j={5,3,1}  由此可得到条件的关系式
			{
				s2-=7-2*s3;
				s1=max(0,s1-(8-s3));  //当箱子放了i个3*3盒子，并尽可能多地放了个2*2盒子后
			}                         //剩下的空间最多放j个1*1盒子，其中i={1,2,3} ; j={7,6,5}
			else                //但当2*2的盒子数不足时，尽可能把1*1盒子放入剩余空间
			{  //一个箱子最多放36个1*1，一个3*3盒子空间最多放9个1*1，一个2*2盒子空间最多放4个1*1
				s1=max(0,s1-(36-9*s3-4*s2));    //由此很容易推出剩余空间能放多少个1*1
				s2=0;
			}
		}

		BoxNum+=(s2+8)/9;       //每9个2*2的盒子完全独占一个箱子
		s2%=9;            //2*2的盒子不足9个时，都放入一个箱子，剩余空间全放1*1
		if(s2)
			s1=max(0,s1-(36-4*s2));

		BoxNum+=(s1+35)/36;     //每36个1*1的盒子完全独占一个箱子

		cout<<BoxNum<<endl;
	}
	return 0;
}



精简NB算法

 #include<stdio.h>
 int main()
 {
 	int n,a,b,c,d,e,f,x,y;
 	int u[4]={0,5,3,1};
 	while(1)
 	{
 		scanf("%d%d%d%d%d%d",&a,&b,&c,&d,&e,&f);
 		if(a==0&&b==0&&c==0&&d==0&&e==0&&f==0)
 			break;
 		n=d+e+f+(c+3)/4;//懂了
 		y=5*d+u[c%4];//在已有n个的情况下，能装下y个2*2的
 		if(b>y)
 			n+=(b-y+8)/9;//把多的2*2的弄进来
 		x=36*n-36*f-25*e-16*d-9*c-4*b;
 		if(a>x)
 			n+=(a-x+35)/36;//把1*1的弄进来
 		printf("%d\n",n);
 	}
 	return 0;
 }