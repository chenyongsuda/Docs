问题： 左移动字符串
老题目有三种方法
1. 普通使用一部分临时内存 移动
2. 三次swap
3. STL Rotary方法 具体介绍相对复杂的Rotary
	如： http://www.cnblogs.com/atyuwen/archive/2009/11/08/rotate.html
	任然不是很懂
	

STL Rotary方法详解
http://blog.csdn.net/xinhanggebuguake/article/details/7498452
http://blog.csdn.net/xinhanggebuguake/article/details/7498471

我们从头开始分析这个问题，对于数组A[0..n-1]，要将其向后循环移动k位元素。因为每个元素右移n位后又回到了原来的位置上，
所以右移k位等于右移k mod n位。考虑每个元素右移k位后的最终位置，比如对于A[0]，右移k位后在k mod n位置上，
原来在k mod n位置上的元素右移k位后到了2*k mod n的位置上，把如此因为A[0]的移动而受到连环影响必须移动的位置列出来，
就是下面这样一个位置序列：0,k,2*k,...,(t-1)k。其中每一项都是在模n的意义下的位置。t*k mod n 的结果是0。
t是使得t*k mod n的结果为0的最小正整数。这个位置序列实质上是模n加法群中由元素k生成的一个循环子群。
由群论中的结论(该结论的证明见最后)知，循环子群(k)的周期为n / gcd(k,n)，元数为n / gcd(k,n)，其陪集个数为gcd(k,n)。
换句话说，A[0..n-1]循环右移k位的结果是循环子群(k)以及它的所有陪集循环右移一位。例如，将A[0..5] = {1,2,3,4,5,6}循环右移4位，
这里n = 6, k = 4, gcd(k, n) = 2。A[0]的最终位置是4,A[4]的最终位置是2,A[2]的最终位置是0，这样，位置0,4,2便是由k=4生成的循环群，
周期为6 / gcd(4,6) = 6 / 2 = 3，这样的循环子群共有gcd(4,6) = 2个。	

个人理解的话
应该是对于长度为n的数组 左移k位 gcd(k,n) = s; 那么就是需要s次rotary_cycle 每一次只能保证1/s 的元素移动到正常位置
具体参考 群论
