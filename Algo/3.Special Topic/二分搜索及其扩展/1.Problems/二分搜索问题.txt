二分搜索  英文术语 BinarySearch

（1）二分搜索分为两种形式
1.闭区间
int binary_search(int array[], int low, int high, int target)
{
    if (low > high) return -1;
    
    int mid = (low + high)/2;
    if (array[mid]> target)
        return binary_search(array, low, mid -1, target);
    if (array[mid]< target)
        return binary_search(array, mid+1, high, target);
    return mid;
}

2.前闭后开区间表示
int binary_search(int array[], int low, int high, int target)
{
    if (low >= high) return -1;
    
    int mid = (low + high)/2;
    if (array[mid]> target)
        return binary_search(array, low, mid, target);
    if (array[mid]< target)
        return binary_search(array, mid+1, high, target);
    return mid;
}

/*==================================================*\
| 二分查找
\*==================================================*/
// 在[l, r)范围内查找值v，返回下标
// 假设a数组已经按从小到大排序
// 失败返回-1
int bs(int a[], int l, int h, int v){
int m;
while ( l < h ){
m = ( l + h ) >> 1;
if (a[m] == v) return m;
if (a[m] < v) l=m+1;
else h=m;
}
return -1;
}

（2）二分查找多种扩展
	1.二分查找找上下界
		举例来说：
		给予数组和目标数
		int array = {2, 3, 5, 7, 11, 13, 17};
		int target = 7;
		那么上界值应该是11，因为它“刚刚好”大于7；下届值则是5，因为它“刚刚好”小于7。
		
		与精确查找不同之处在于，精确查找分成三类：大于，小于，等于（目标数）。而界限查找则分成了两类：大于和不大于。
		
		
		1.严格上下界
		
		2.松散界限
		取大于等于   小于等于
		
		实例： 	1. 求上届
				2. 求下届
				3. 大于等于的第一个数
				4. 小于等于的第一个数
	2.找到以一个大于等于X的某个数（小于等于）
		算法模板中的方法
		/*==================================================*\
		| 二分查找（大于等于v的第一个值）第一个等于或者第一个大于的
		\*==================================================*/
		// 传入参数必须l <= h
		// 返回值l总是合理的
		int bs(int a[], int l, int h, int v){
		int m;
		while ( l < h ){
		m = ( l + h ) >> 1;
		if (a[m] < v) l=m+1;
		else h=m;
		}
		return l;
		}
		/*==================================================*\
		
		比较难理解
		比较好理解的
		可以参考九度OJhttp://ac.jobdu.com/problem.php?pid=1386我的做法
		思想是最终可以分为剩1个 和2个长度
		

	具体详细容易理解的算法参考 文档<二分查找汇总>
	
	
	3. 二分查找  查找范围
		结合查询上界和下界的函数
	
	4. 在轮转后的有序数组上应用二分查找法
		1. 限定元素各不相同
		2. 包含相同元素
		
		参考http://www.gocalf.com/blog/circularly-ordinal-array.html
		
		显然传统的二分法已经无法直接使用了，但考虑一下，如果已经知道分界点位置，那问题就简单多了，只要先判断一下待查元素是在分界点的左侧还是右侧，然后直接对那一侧的半个数组使用二分查找。
		那怎么找分界点呢？它的特点是它左边的元素都比右边的元素大。借鉴二分查找的思想，选取中间的元素，拿它跟两端的元素比一比，分析出分界点是在左半边还是右半边，然后在对那半个数组递归处理。
		第一个元素应该是分界点左边最小的一个元素，但又不小于分界点右边的所有元素。那么如果中间元素比它大，分界点只能在中间元素的右边；反之，如果中间元素比它小，分界点就一定在左半边。如果二者相等，就需要比较再拿最后一个元素来比较，如果中间元素比最后一个元素大，分界点在右边；反之，如果中间元素比最后一个元素小，分界点在左边。如果还相等，那麻烦就来了。
		考虑下面这张图中的两种情况（A和B），显然，第一次二分处理的时候，这两种情况下，第一个、中间的和最后一个元素都是彼此相等的，但分界点却可能在左边也可能在右边。

		可见先找分界点的方法在这种情况下是行不通的。
		另外一种方法，是直接使用一种变体的二分法，相当于把找分界点跟搜索指定数值结合起来，也就是每次二分的时候，除了跟中间值做比较外，也要跟两端的数值做比较，以此来确定对哪一半进行分治递归处理。然而这种方法对于上图中的情况依旧是无能为力的。
		对于类似于上图中的输入，能否用log n时间找到指定元素呢？我还没想好-_-
		我们还是先考虑没有重复值的情况吧，按照第二种想法（变体的二分法）写出算法，时间复杂度是log n：
		
		

