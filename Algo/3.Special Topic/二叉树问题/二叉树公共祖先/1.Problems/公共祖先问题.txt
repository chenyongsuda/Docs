最近公共祖先问题  英文术语 Lowest common ancestor

1.	根据树的存储结构，我们可以立刻得到一个这样的算法：从两个给定的结点出发回溯，两条回溯路线的交点就是我们要找的东西。
这个算法的具体实现办法是：从根 结点开始，先用这两个结点的全体祖先分别生成两个链表，再把这两个链表第一次出现不同结点的位置找出来，
则它们的前一个结点就是我们要找的东西。这个算法倒没有什么不好的地方，但是它没有利用二元搜索树的任何特征。

		20
	8		22
4		12
	10 		14	

仔细研究，4和14的最低公共祖先是8，它与4和14的其他公共祖先是有重要区别的：其他的公共祖 先或者同时大于4和14，或者同时小于4和14，
只有8介于4和14之间。利用这一研究成果，我们就能得到一个更好的算法。
从根结点出发，沿着两个给定结点的公共祖先前进。当这两个结点的值同时小于当前结点的值时，
沿当前结点的左指针前进；当这两个结点的值同时大于当前结点的 值时，沿当前结点的右指针前进；
当第一次遇到当前结点的值介于两个给定的结点值之间的情况时，这个当前结点就是我们要找的最的最低公共祖先了。

如果是普通二叉树该怎么做
1. 可以通过DFS 查找两个点的路径 然后比较连个节点第一个不相同的点
2. 上面这张方法用了额外空间并且也不是很高效,是否可以更好
	一次DF就够了，搜索一个node t的时候，
	如果他以t为根的子树里有node 1，就返回1，有node 2，就返回2，两个node都有，就返回3，
	剩下只利用一个bool值就可以记录第一个返回3的node


2. 如果节点结构是
	class Node  
	{  
	   Node * left;  
	   Node * right;  
	   Node * parent;  
	};  

知道parent的话,	1.可以循环比较一个中的Key是否和另一个中的某个匹配 复杂度n 平方
				2.可以按照这个条件网上找 找到头然后保存为两个数组找第一个不相同的 复杂度 n+m

				






