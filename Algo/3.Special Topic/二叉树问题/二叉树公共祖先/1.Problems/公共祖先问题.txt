最近公共祖先问题  英文术语 Lowest common ancestor

1.	根据树的存储结构，我们可以立刻得到一个这样的算法：从两个给定的结点出发回溯，两条回溯路线的交点就是我们要找的东西。
这个算法的具体实现办法是：从根 结点开始，先用这两个结点的全体祖先分别生成两个链表，再把这两个链表第一次出现不同结点的位置找出来，
则它们的前一个结点就是我们要找的东西。这个算法倒没有什么不好的地方，但是它没有利用二元搜索树的任何特征。

		20
	8		22
4		12
	10 		14	

仔细研究，4和14的最低公共祖先是8，它与4和14的其他公共祖先是有重要区别的：其他的公共祖 先或者同时大于4和14，或者同时小于4和14，
只有8介于4和14之间。利用这一研究成果，我们就能得到一个更好的算法。
从根结点出发，沿着两个给定结点的公共祖先前进。当这两个结点的值同时小于当前结点的值时，
沿当前结点的左指针前进；当这两个结点的值同时大于当前结点的 值时，沿当前结点的右指针前进；
当第一次遇到当前结点的值介于两个给定的结点值之间的情况时，这个当前结点就是我们要找的最的最低公共祖先了。


2. 如果节点结构是
	class Node  
	{  
	   Node * left;  
	   Node * right;  
	   Node * parent;  
	};  

知道parent的话,	1.可以循环比较一个中的Key是否和另一个中的某个匹配 复杂度n 平方
				2.可以按照这个条件网上找 找到头然后保存为两个数组找第一个不相同的 复杂度 n+m

				






