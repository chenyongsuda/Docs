1.算法描述：
一个栈stack，具有push和pop操作，其时间复杂度皆为O(1)。
设计算法max操作，求栈中的最大值，该操作的时间复杂度也要求为O(1)。
可以修改栈的存储方式，push，pop的操作，但是要保证O(1)的时间复杂度，空间时间复杂度无要求。


2.在excel中有如下对的关系
A  B C ......Z   AA.....AZ   BA....BZ............AAA................ZZZ..............
1..............26  27......52  53.....................703.................................
编写函数 fun（String  str ） 输入第一行中的任意一个字符串，输出对应的整数值。



3.有50个人围成一个圈数数Φ谝桓鋈舜1开始数数Φ笔到是3的倍数的人就会出列κＯ碌娜思绦接着数
  问最后剩下的人一开始是排在几号的.
  
  具体分析 http://blog.csdn.net/fzydao/article/details/7041541 （约瑟夫环数学解法）
  文档： 约瑟夫问题!.txt
  
  一共有两种解法: 1.模拟过程  2.数学解法

  
4.找出数组中重复次数最多的元素并打印
	1.个人思路 hash 统计 然后选出最大的
	2.排序 然后顺序扫描

5.一个链表，只给指向该节点的指针，怎么删除
	如果不是最后一个节点，直接把后一个赋值给前一个，然后删除后一个节点。否则得重新遍历。

6.16瓶药水，一瓶不一样。放在一起发生化学反应。最少用几个试管可检测。

7.char *s=”abcde”。Sizeof(s)和strlen(s)有什么区别
	s是指针，sizeof就是4
	大部分编译程序 在编译的时候就把sizeof计算过了 是类型或是变量的长度这就是sizeof(x)可以用来定义数组维数的原因 
	char str[20]="0123456789";
	int a=strlen(str); //a=10;
	int b=sizeof(str); //而b=20;
	
8.计算字符串相似性
	许多程序会大量使用字符串。对于不同的字符串，我们希望能够有办法判断其相似程序。我们定义一套操作方法来把两个不相同的字符串变得相同，具体的操作方法为：
　　1.修改一个字符（如把“a”替换为“b”）;

　　2.增加一个字符（如把“abdd”变为“aebdd”）;

　　3.删除一个字符（如把“travelling”变为“traveling”）;

　　比如，对于“abcdefg”和“abcdef”两个字符串来说，我们认为可以通过增加/减少一个“g”的方式来达到目的。上面的两种方案，都仅需要一 次 。把这个操作所需要的次数定义为两个字符串的距离，而相似度等于“距离+1”的倒数。也就是说，“abcdefg”和“abcdef”的距离为1，相似度 为1/2=0.5。

　　给定任意两个字符串，你是否能写出一个算法来计算它们的相似度呢？
	d[i][j] = MIN((d[i - 1][j] + COST[DELETE]), (d[i,j-1]  + COST[ADD]), (d[d[i-1][j-1] + COST[REPLACE]]))

  
9.给一个循环有序数组，用logn算法求一个数的位置。我就说第一次二分查找临界点，
第二次利用临界点位置再二分查找那个数。然后他让我把查找临界点的代码写一下
题目：
	问题描述：给定一个由n个各不相等的元素构成的循环有序数组（Circularly Ordinal Array），用 O(log n) 时间、O(1) 辅助空间在其中查找指定的元素。
	所谓循环有序数组，就是把一个排好序（以升序排列为例）的数组从某个（未知）位置处截为两段，把前一段放到后一段的后面，所得到的数组。
	比如 { 8, 9, 10, 0, 1, 2, 3, 4, 5, 6, 7 }。如果把数组首尾相接，看成一个环形，那么数组就还是有序的，只不过最小值有可能在任何一个位置。
	从最小值开始向后，数值逐渐递增，到数组的最后一个元素时再回到第一个元素。
	
	解答：可以分为两部1.二分查找临界点2.在两部分二分查找
	
	用s代表首号元素，m代表中间元素，e代表末尾元素，那么根据中间元素就可以把整个数组分成两个子数组：s1,s2；
	（这里我有一个纠结的地方，就是当数组个数为偶数时，中间元素m到底分到哪个子数组中去，其实这里有的时候并不是关键因素，即分到哪边去都一样，具体要看下一步是怎么操作的）
	这样的话，因为是循环有序的数组，两个子数组s1,s2中肯定有一个是有序的，而另一个是无序的，那么如果要查找的数字在有序的这个子数组里，那就可以直接用二分查找了，
	如果不是的话就再继续这样分，直到他在有序的那一边。这样就是从部分有序着手解决问题了。
 
10. 第二道题是一堆村庄，输入这些村庄哪几对是可达的，然后查询两个村庄是否可达。
	我说用并查集。接着把merge的代码写好，find的思路跟他说下，他表示认可。
	然后又问如果只查询一次该怎么做，我说宽搜或者深搜。把宽搜的思路说下，这个比较简单。 
	
11. 一个人1/2的概率去酒馆，1/2呆家里。酒馆有8个，去的概率都是一样的。另一个人去酒馆找他，
	发现前7个酒馆都不在，问在第8个酒馆的概率。我想的时间略长，然后他问该怎么做。我说用贝叶斯定理，他说对，就换题了。 
  
12. 给10亿个数去重，我就说分段用bitmap。他说bitmap怎么做，我就说用STL啊。然后让我自己实现，简单地写了个代码。 

13. 六度定理，(Six Degrees of Kevin Bacon)任意两个不认识的人之间最多只有六个人形成一条链。想一个算法求两个人之间的度。有什么可以 trade-off, 有什么可以优化的。
	那究竟什么是六度分离理论呢？六度分离理论（Six Degrees of Separation）：“你和任何一个陌生人之间所间隔的人不会超过五个，也就是说，
	最多通过五个人你就能够认识任何一个陌生人。”根据这个理论，你和世界上的任何一个人之间只隔着五个人，不管对方在哪个国家，属哪类人种，
	是哪种肤色。

14. 一个数组(长度小于1000)找最大值，是用 Bubble Sort 还是 Merge Sort？ 如果数组长度大于1000，用哪一个？
	我觉得是都用Bubble Sort只要找最大值的话 一次Bubble Sort 复杂度为n

15. 5个6面标准骰子，掷出“至少2个4”的概率是多少。

16. 给定一个数组和一个整数X，找出一对数满足a+b=X。
	两个指针 按照条件向中间逼近
	
17. 判定一个二叉树是否为二叉搜索树
	中根遍历 判断是否是有序的
	
18. 问的是两个string1，和string2，怎么判断string1是不是string2的subsequence   要是SubString又如何
	子序列  子串问题
	
19. 怎样reverse string但是保证space的位置不变
	
20. 一个BST和一个string，怎么找到common的element
	
21. string palindrome(回文)，还有两个array找duplicate

22. 一串string，每一个word被“@”分割，写个function，return array words。

23. 有一个int数组，每个int的范围都是1到10000，找出最小的不存在的数。比如array={3,1,4} return 2
	bitMap  

24. 输入两个string判断是不是anagram(只判断字母，但是string里可以有其他字符， 比如“cat”, "act", "t c a", "at[c]"， 都会返回true)
	
25. 在一个binary tree中，找到两个node的公共祖先。然后继续问，如果node有一个pointer指向parent， 要求空间O（1）
	
26. 有一个unsorted int array有100个元素， 每个元素都是1到100之间的，如果有重复的元素， 把它找出来。（不能修改数组，空间O（1））
	设定100各位
27. 给一个single linked list找到中间的元素 
	一个指针跳一下 一个跳两下
28. 写一个m的n次方的函数

29. 判断两个tree是否是mirror

30. merge sort

31. 将一个单链表逆转――原来的头指针变为尾指针，原来的尾指针变为头指针。

32.
算法题：
Q1. 给你一大串数字，你不知道有多少个数字，如何从中*随机等概率*地挑出一个数字？问一个恒定内存的方法（常数内存）
Q2. 给你一大串价格，比如，股价。如何决定最好的买入和卖出时机？
	http://blog.sina.com.cn/s/blog_4c7152af0100g7ig.html
	如果你知道一支股票在n天里的所有价格，如何确定买入和卖出的时间，使自己一次买卖赚最多？

33.
编程题：
Q1 写一个可以按顺序打印二叉树的方法(Java)
Q2 写一个函数：输入是一个整数，返回是一个字符串，内容是这个整数的八进制表达(C++)

34.
【题目1】单峰数组(<算法设计>)
一个数组中的数值随着下标的编号的增大，先增大后减小。如何求峰值数值的下标？

35.
【题目6】银行卡测试
有仪器可以检测两张银行卡是否使用同一个账号。
有n张银行卡，是否有n/2张以上是使用同一个账号？

36. 
【题目5】重要逆序对
数组a[1..n],有多少对(i,j),使得i<j且，a[i]>2a[j]?
想想：逆序对的加强版本！

37.
【题目4】逆序对
数组a[1..n],有多少对(i,j),使得i<j且，a[i]>a[j]?
想想：从中间开始拆？似乎是一个归并排序的附带产物？

38.
atoi()实现
1、检查字符串是否为空

2、对非法输入，返回0，并设置全局变量

3、溢出

4、空字符串""

5、输入字符串只有"+"或"-"号

39. 是逆波兰表达式的计算

40. 单例模式
	http://en.wikipedia.org/wiki/Double-checked_locking
41. Hash Table，如何实现，怎样避免冲突，怎样保证universal hash

42. Coding: given an array of integer, find the 2nd largest one

43. Coding: given an array of integer a[], remove duplicates and return a non-duplicate array of integer b[]

44.  Print the first non-duplicate character of a string.(e.g abcba -> c ;  accxay -> x)

45. 150题目 中矩形中翻0

46. 怎样实现一个power函数，比如 3,2 -> 9 ; 10,3 ->1000（non-recursive version)

47. 用linked list做个stack

48. 二叉树的common ancestor。输入是两个node ptr和这个二叉树的root ptr, 
	输出是他们的最深common ancestor。我想到的算法是从root开始搜索，把两个node到root的path记录下来，
	然后进行比较就行了。M说正确是正确，时间复杂度也够，只是杂七杂八的开销太多让我再想。
	我绞尽脑汁他百般提示就是想不出来。后来他把答案告诉了我：一次DF就够了，搜索一个node t的时候，
	如果他以t为根的子树里有node 1，就返回1，有node 2，就返回2，两个node都有，就返回3，
	剩下只利用一个bool值就可以记录第一个返回3的node，他就是要找的节点。好鞋又高效。lz拜服。
	（事实上lz面试的时候没听太懂，回来想了想才懂得，汗。。。）
	
49. 第一题：链表内容的反转，比如1->2->3变为3->2->1。但是不能改变链表的内存顺序，所以只能修改这些node的内容了。
	这题很明显我就用了个stack就做出来了，他又要求不能用buffer，我就写了一个递归，当然是O(N^2)的那种。他继续要求改进，
	lz又抓耳挠腮一番也同样的想不出。结果他就展示了一个O(N)的递归算法，思想与lz写的string revers一样
	https://gist.github.com/2407515（。。。其实是我模仿他）
	当时觉得好高明啊，出来一向才发现这不是调用系统栈嘛，原来又是坑啊。。。
	其实reverse linked list， 可以用一个XOR swap..一样不需要buffer,也是O(n); 不过用recursive stack不要太美！
	
	//assume the input is integer, but any type works 
	void xorSwap (int *x, int *y) {
		 if (x != y) {
			 *x ^= *y;
			 *y ^= *x;
			 *x ^= *y;
		 }
	}
50. 猜数字策略 已知[0,n]猜一个数,如果n未知该怎么猜

51.	1.给你个整数，记录这个数所有不可拆分的因子（素数）例如 12 ―结果[2,2,3]
	  思路:n/x x->[1,X]
	2.给定一个整数n，输出这个整数拆分的可能总数

52. 实现一个hashtable

53. 三个数组的交集

54. 1.给我一全是数字的array，说这里面的每个数字在这个array里面，只有一个出现的频率是偶数其他的都是奇数，把那个出线频率是偶数的哥们找出来
	2. 从n个数中找出重复的或缺少的某个数或者多个数的小结

55. [1]二叉树遍历.[2]找出二叉树中the kth largest number

56. Reverse Linked List	no.2 打印一个string所有可能的subset的anagram，
	怎么写简历，我是看了板上一位神人的帖子，写出来的简历，每次有人回复都是说，
	impressive resume, brilliant。。。。
	我自己的资料存在evernote,有兴趣可以看看，不过不要人肉我。。。

	http://www.evernote.com/shard/s177/sh/e0a6c4d4-c131-4de6-a8f1-9

	http://www.evernote.com/shard/s177/sh/5203d4f1-995e-4664-8bde-c
