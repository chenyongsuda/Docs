1.算法描述：
一个栈stack，具有push和pop操作，其时间复杂度皆为O(1)。
设计算法max操作，求栈中的最大值，该操作的时间复杂度也要求为O(1)。
可以修改栈的存储方式，push，pop的操作，但是要保证O(1)的时间复杂度，空间时间复杂度无要求。


2.在excel中有如下对的关系
A  B C ......Z   AA.....AZ   BA....BZ............AAA................ZZZ..............
1..............26  27......52  53.....................703.................................
编写函数 fun（String  str ） 输入第一行中的任意一个字符串，输出对应的整数值。



3.有50个人围成一个圈数数Φ谝桓鋈舜1开始数数Φ笔到是3的倍数的人就会出列κＯ碌娜思绦接着数
  问最后剩下的人一开始是排在几号的.
  
  具体分析 http://blog.csdn.net/fzydao/article/details/7041541 （约瑟夫环数学解法）
  文档： 约瑟夫问题!.txt
  
  一共有两种解法: 1.模拟过程  2.数学解法

  
4.找出数组中重复次数最多的元素并打印
	1.个人思路 hash 统计 然后选出最大的
	2.排序 然后顺序扫描

5.一个链表，只给指向该节点的指针，怎么删除
	如果不是最后一个节点，直接把后一个赋值给前一个，然后删除后一个节点。否则得重新遍历。

6.16瓶药水，一瓶不一样。放在一起发生化学反应。最少用几个试管可检测。

7.char *s=”abcde”。Sizeof(s)和strlen(s)有什么区别
	s是指针，sizeof就是4
	大部分编译程序 在编译的时候就把sizeof计算过了 是类型或是变量的长度这就是sizeof(x)可以用来定义数组维数的原因 
	char str[20]="0123456789";
	int a=strlen(str); //a=10;
	int b=sizeof(str); //而b=20;
	
8.计算字符串相似性
	许多程序会大量使用字符串。对于不同的字符串，我们希望能够有办法判断其相似程序。我们定义一套操作方法来把两个不相同的字符串变得相同，具体的操作方法为：
　　1.修改一个字符（如把“a”替换为“b”）;

　　2.增加一个字符（如把“abdd”变为“aebdd”）;

　　3.删除一个字符（如把“travelling”变为“traveling”）;

　　比如，对于“abcdefg”和“abcdef”两个字符串来说，我们认为可以通过增加/减少一个“g”的方式来达到目的。上面的两种方案，都仅需要一 次 。把这个操作所需要的次数定义为两个字符串的距离，而相似度等于“距离+1”的倒数。也就是说，“abcdefg”和“abcdef”的距离为1，相似度 为1/2=0.5。

　　给定任意两个字符串，你是否能写出一个算法来计算它们的相似度呢？
	d[i][j] = MIN((d[i - 1][j] + COST[DELETE]), (d[i,j-1]  + COST[ADD]), (d[d[i-1][j-1] + COST[REPLACE]]))

  
9.给一个循环有序数组，用logn算法求一个数的位置。我就说第一次二分查找临界点，
第二次利用临界点位置再二分查找那个数。然后他让我把查找临界点的代码写一下
题目：
	问题描述：给定一个由n个各不相等的元素构成的循环有序数组（Circularly Ordinal Array），用 O(log n) 时间、O(1) 辅助空间在其中查找指定的元素。
	所谓循环有序数组，就是把一个排好序（以升序排列为例）的数组从某个（未知）位置处截为两段，把前一段放到后一段的后面，所得到的数组。
	比如 { 8, 9, 10, 0, 1, 2, 3, 4, 5, 6, 7 }。如果把数组首尾相接，看成一个环形，那么数组就还是有序的，只不过最小值有可能在任何一个位置。
	从最小值开始向后，数值逐渐递增，到数组的最后一个元素时再回到第一个元素。
	
	解答：可以分为两部1.二分查找临界点2.在两部分二分查找
	
	用s代表首号元素，m代表中间元素，e代表末尾元素，那么根据中间元素就可以把整个数组分成两个子数组：s1,s2；
	（这里我有一个纠结的地方，就是当数组个数为偶数时，中间元素m到底分到哪个子数组中去，其实这里有的时候并不是关键因素，即分到哪边去都一样，具体要看下一步是怎么操作的）
	这样的话，因为是循环有序的数组，两个子数组s1,s2中肯定有一个是有序的，而另一个是无序的，那么如果要查找的数字在有序的这个子数组里，那就可以直接用二分查找了，
	如果不是的话就再继续这样分，直到他在有序的那一边。这样就是从部分有序着手解决问题了。
 
10. 第二道题是一堆村庄，输入这些村庄哪几对是可达的，然后查询两个村庄是否可达。
	我说用并查集。接着把merge的代码写好，find的思路跟他说下，他表示认可。
	然后又问如果只查询一次该怎么做，我说宽搜或者深搜。把宽搜的思路说下，这个比较简单。 
	
11. 一个人1/2的概率去酒馆，1/2呆家里。酒馆有8个，去的概率都是一样的。另一个人去酒馆找他，
	发现前7个酒馆都不在，问在第8个酒馆的概率。我想的时间略长，然后他问该怎么做。我说用贝叶斯定理，他说对，就换题了。 
  
12. 给10亿个数去重，我就说分段用bitmap。他说bitmap怎么做，我就说用STL啊。然后让我自己实现，简单地写了个代码。 

13. 六度定理，(Six Degrees of Kevin Bacon)任意两个不认识的人之间最多只有六个人形成一条链。想一个算法求两个人之间的度。有什么可以 trade-off, 有什么可以优化的。
	那究竟什么是六度分离理论呢？六度分离理论（Six Degrees of Separation）：“你和任何一个陌生人之间所间隔的人不会超过五个，也就是说，
	最多通过五个人你就能够认识任何一个陌生人。”根据这个理论，你和世界上的任何一个人之间只隔着五个人，不管对方在哪个国家，属哪类人种，
	是哪种肤色。

14. 一个数组(长度小于1000)找最大值，是用 Bubble Sort 还是 Merge Sort？ 如果数组长度大于1000，用哪一个？
	我觉得是都用Bubble Sort只要找最大值的话 一次Bubble Sort 复杂度为n

15. 5个6面标准骰子，掷出“至少2个4”的概率是多少。

16. 给定一个数组和一个整数X，找出一对数满足a+b=X。
	两个指针 按照条件向中间逼近
	
17. 判定一个二叉树是否为二叉搜索树
	中根遍历 判断是否是有序的
	
18. 问的是两个string1，和string2，怎么判断string1是不是string2的subsequence   要是SubString又如何
	子序列  子串问题
	
19. 怎样reverse string但是保证space的位置不变
	
20. 一个BST和一个string，怎么找到common的element
	
21. string palindrome(回文)，还有两个array找duplicate

22. 一串string，每一个word被“@”分割，写个function，return array words。

23. 有一个int数组，每个int的范围都是1到10000，找出最小的不存在的数。比如array={3,1,4} return 2
	bitMap  

24. 输入两个string判断是不是anagram(只判断字母，但是string里可以有其他字符， 比如“cat”, "act", "t c a", "at[c]"， 都会返回true)
	
25. 在一个binary tree中，找到两个node的公共祖先。然后继续问，如果node有一个pointer指向parent， 要求空间O（1）
	
26. 有一个unsorted int array有100个元素， 每个元素都是1到100之间的，如果有重复的元素， 把它找出来。（不能修改数组，空间O（1））
	设定100各位
27. 给一个single linked list找到中间的元素 
	一个指针跳一下 一个跳两下
28. 写一个m的n次方的函数

29. 判断两个tree是否是mirror

30. merge sort

31. 将一个单链表逆转――原来的头指针变为尾指针，原来的尾指针变为头指针。


