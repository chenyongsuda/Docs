1.算法描述：
一个栈stack，具有push和pop操作，其时间复杂度皆为O(1)。
设计算法max操作，求栈中的最大值，该操作的时间复杂度也要求为O(1)。
可以修改栈的存储方式，push，pop的操作，但是要保证O(1)的时间复杂度，空间时间复杂度无要求。


2.在excel中有如下对的关系
A  B C ......Z   AA.....AZ   BA....BZ............AAA................ZZZ..............
1..............26  27......52  53.....................703.................................
编写函数 fun（String  str ） 输入第一行中的任意一个字符串，输出对应的整数值。



3.有50个人围成一个圈数数Φ谝桓鋈舜1开始数数Φ笔到是3的倍数的人就会出列κＯ碌娜思绦接着数
  问最后剩下的人一开始是排在几号的.
  
  具体分析 http://blog.csdn.net/fzydao/article/details/7041541 （约瑟夫环数学解法）
  文档： 约瑟夫问题!.txt
  
  一共有两种解法: 1.模拟过程  2.数学解法

  
4.找出数组中重复次数最多的元素并打印
	1.个人思路 hash 统计 然后选出最大的
	2.排序 然后顺序扫描

5.一个链表，只给指向该节点的指针，怎么删除
	如果不是最后一个节点，直接把后一个赋值给前一个，然后删除后一个节点。否则得重新遍历。

6.16瓶药水，一瓶不一样。放在一起发生化学反应。最少用几个试管可检测。

7.char *s=”abcde”。Sizeof(s)和strlen(s)有什么区别
	s是指针，sizeof就是4
	大部分编译程序 在编译的时候就把sizeof计算过了 是类型或是变量的长度这就是sizeof(x)可以用来定义数组维数的原因 
	char str[20]="0123456789";
	int a=strlen(str); //a=10;
	int b=sizeof(str); //而b=20;
	
8.计算字符串相似性
	许多程序会大量使用字符串。对于不同的字符串，我们希望能够有办法判断其相似程序。我们定义一套操作方法来把两个不相同的字符串变得相同，具体的操作方法为：
　　1.修改一个字符（如把“a”替换为“b”）;

　　2.增加一个字符（如把“abdd”变为“aebdd”）;

　　3.删除一个字符（如把“travelling”变为“traveling”）;

　　比如，对于“abcdefg”和“abcdef”两个字符串来说，我们认为可以通过增加/减少一个“g”的方式来达到目的。上面的两种方案，都仅需要一 次 。把这个操作所需要的次数定义为两个字符串的距离，而相似度等于“距离+1”的倒数。也就是说，“abcdefg”和“abcdef”的距离为1，相似度 为1/2=0.5。

　　给定任意两个字符串，你是否能写出一个算法来计算它们的相似度呢？
	d[i][j] = MIN((d[i - 1][j] + COST[DELETE]), (d[i,j-1]  + COST[ADD]), (d[d[i-1][j-1] + COST[REPLACE]]))

  
9.给一个循环有序数组，用logn算法求一个数的位置。我就说第一次二分查找临界点，
第二次利用临界点位置再二分查找那个数。然后他让我把查找临界点的代码写一下
题目：
	问题描述：给定一个由n个各不相等的元素构成的循环有序数组（Circularly Ordinal Array），用 O(log n) 时间、O(1) 辅助空间在其中查找指定的元素。
	所谓循环有序数组，就是把一个排好序（以升序排列为例）的数组从某个（未知）位置处截为两段，把前一段放到后一段的后面，所得到的数组。
	比如 { 8, 9, 10, 0, 1, 2, 3, 4, 5, 6, 7 }。如果把数组首尾相接，看成一个环形，那么数组就还是有序的，只不过最小值有可能在任何一个位置。
	从最小值开始向后，数值逐渐递增，到数组的最后一个元素时再回到第一个元素。
	
	解答：可以分为两部1.二分查找临界点2.在两部分二分查找
	
	用s代表首号元素，m代表中间元素，e代表末尾元素，那么根据中间元素就可以把整个数组分成两个子数组：s1,s2；
	（这里我有一个纠结的地方，就是当数组个数为偶数时，中间元素m到底分到哪个子数组中去，其实这里有的时候并不是关键因素，即分到哪边去都一样，具体要看下一步是怎么操作的）
	这样的话，因为是循环有序的数组，两个子数组s1,s2中肯定有一个是有序的，而另一个是无序的，那么如果要查找的数字在有序的这个子数组里，那就可以直接用二分查找了，
	如果不是的话就再继续这样分，直到他在有序的那一边。这样就是从部分有序着手解决问题了。
 
10. 第二道题是一堆村庄，输入这些村庄哪几对是可达的，然后查询两个村庄是否可达。
	我说用并查集。接着把merge的代码写好，find的思路跟他说下，他表示认可。
	然后又问如果只查询一次该怎么做，我说宽搜或者深搜。把宽搜的思路说下，这个比较简单。 
	
11. 一个人1/2的概率去酒馆，1/2呆家里。酒馆有8个，去的概率都是一样的。另一个人去酒馆找他，
	发现前7个酒馆都不在，问在第8个酒馆的概率。我想的时间略长，然后他问该怎么做。我说用贝叶斯定理，他说对，就换题了。 
  
12. 给10亿个数去重，我就说分段用bitmap。他说bitmap怎么做，我就说用STL啊。然后让我自己实现，简单地写了个代码。 

13. 

