约瑟夫问题（转）2009年04月05日 星期日 22:09Josephus问题：假设n个竞赛者排成一个环形，依次顺序编号1，2，…，n。从某个指定的第1号开始，沿环计数，每数到第m个人就让其出列，且从下一个人开始重新计数，继续进行下去。这个过程一直进行到所有的人都出列为止。最后出列者为优胜者。无论是用链表实现还是用数组实现来解约瑟夫问题都有一个共同点：要模拟整个游戏过程，不仅程序写起
来比较麻烦，而且时间复杂度高达O(nm)，当n，m非常大(例如上百万，上千万)的时候，几乎是没有办法在短时间内出结果的。注意到原问题仅仅是要求出最后的胜利者的序号，而不是要模拟整个过程。因此如果要追求效率，就要打破常规，实施一点数学策略。

为了讨论方便，先把问题稍微改变一下，并不影响原意：

问题描述：n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人继续从0开始报数。求胜利者的编号。

我们知道第一个人(编号一定是m%n-1) 出列之后，剩下的n-1个人组成了一个新的约瑟夫环
（以编号为k=m%n的人开始）:
    k    k+1    k+2    ... n-2, n-1, 0, 1, 2, ... k-2
并且从k开始报0。

现在我们把他们的编号做一下转换：
k       --> 0
k+1     --> 1
k+2     --> 2
...
...
k-2     --> n-2
k-1     --> n-1

变换后就完完全全成为了(n-1)个人报数的子问题，假如我们知道这个子问题的解：例如x
是最终的胜利者，那么根据上面这个表把这个x变回去不刚好就是n个人情况的解吗？变
回去的公式很简单：x'=(x+k)%n

如何知道(n-1)个人报数的问题的解？显然，只要知道(n-2)个人的解就行了。(n-2)个人的解
呢？当然是先求(n-3)的情况 ---- 这显然就是一个倒推问题！
递推公式：

令f[i]表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n]

递推公式
f[1]=0;
f[i]=(f[i-1]+m)%i;    (i>1)

有了这个公式，我们要做的就是从1-n顺序算出f[i]的数值，最后结果是f[n]。因为实际生
活中编号总是从1开始，我们输出f[n]+1

由于是逐级递推，不需要保存每个f[i]，程序也是很简单：#include <stdio.h>
main()
{
  int n, m, i, s=0;
  printf ("N M = "); 
  scanf("%d%d", &n, &m);
  for (i=2; i<=n; i++) s=(s+m)%i;
  printf ("The winner is %d\n", s+1);
}
 

这个算法的时间复杂度为O(n)，相对于模拟算法已经有了很大的提高。算n，m等于一百万，一千万的情况不是问题了。可见，适当地运用数学策略，不仅可以让编程变得简单，而且往往会成倍地提高算法执行效率。 

