题目1107：搬水果

题目描述：
    在一个果园里，小明已经将所有的水果打了下来，并按水果的不同种类分成了若干堆，小明决定把所有的水果合成一堆。每一次合并，小明可以把两堆水果合并到一起，消耗的体力等于两堆水果的重量之和。当然经过 n\1 次合并之后，就变成一堆了。小明在合并水果时总共消耗的体力等于每次合并所耗体力之和。
    假定每个水果重量都为 1，并且已知水果的种类数和每种水果的数目，你的任务是设计出合并的次序方案，使小明耗费的体力最少，并输出这个最小的体力耗费值。例如有 3 种水果，数目依次为 1，2，9。可以先将 1，2 堆合并，新堆数目为3，耗费体力为 3。然后将新堆与原先的第三堆合并得到新的堆，耗费体力为 12。所以小明总共耗费体力=3+12=15，可以证明 15 为最小的体力耗费值。
输入：
    每组数据输入包括两行,第一行是一个整数 n(1<=n<=10000),表示水果的种类数，如果 n 等于 0 表示输入结束，且不用处理。第二行包含 n 个整数，用空格分隔，第 i 个整数(1<=ai<=1000)是第 i 种水果的数目。
输出：
对于每组输入，输出一个整数并换行，这个值也就是最小的体力耗费值。输入数据保证这个值小于 2^31。
样例输入：
3
9 1 2
0
样例输出：
15

网上的思路

// 先分析问题,运用递归思想解析问题
// 1.如果只有一堆水果x1,则不用搬
// 2.如果有两堆水果x1和x2,则只需搬一次,且方法唯一
// 3.如果有三堆水果x1、x2和x3,则有三种搬运方法:
//   3.1若先搬x1和x2,则体力耗费值为H1=2*(x1+x2)+x3;
//   3.2若先搬x1和x3,则体力耗费值为H2=2*(x1+x3)+x2;
//   3.3若先搬x2和x3,则体力耗费值为H3=x1+2*(x2+x3);
//   3.4很显然,若x1、x2都小于x3,则H1最小;x1、x3都小于x2时,H2最小;x2、x3都小于x1时,H3最小;
//   3.5也就是和并三者中的较小的两堆可是耗费体力值最小
// 4.如果有四堆水果x1、x2、x3和x4,则必须先合并其中的两堆，然后就成了三堆水果
//   4.1问题就集中在先合并哪两堆呢？
//   4.2分析3.5的结论及体力耗费值公式，不难推出：三堆中的较小两堆之和越小体力耗费值越小
//   4.3所以,先合并最小的两堆，然后构成第三堆
// 5.依次这样递推，得出结论，每次都合并最小的两堆可是体力耗费值最小
//
// 延伸:每次都选择最小的两个数组合，是否让你想到了huffman_Tree?
// 实际上，这也就是求带权路径长度WPL的最小值问题
// 当然，如果这题要去建立Huffman_Tree去解决问题就太麻烦了,而且Huffman_Tree也不是那么好构建的
// 问题的答案就是Huffman_Tree中所有非终端节点的值的和,我就用结构体数组解决问题算了

其实思路也可以这样看

假设5堆   a b c d e
结果为(a + b) * n-1 + c * n-2 + d*n-3  +e*n-4
和哈夫曼树是一样的公式
