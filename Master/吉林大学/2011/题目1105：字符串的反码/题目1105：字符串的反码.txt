题目1105：字符串的反码

题目描述：
    一个二进制数，将其每一位取反，称之为这个数的反码。下面我们定义一个字符的反码。如果这是一个小写字符，则它和字符'a’的距离与它的反码和字符'z’的距离相同；如果是一个大写字符，则它和字符'A’的距离与它的反码和字符'Z’的距离相同；如果不是上面两种情况，它的反码就是它自身。
    举几个例子，'a’的反码是'z’；'c’的反码是'x’；'W’的反码是'D’；'1’的反码还是'1’；'$'的反码还是'$'。
    一个字符串的反码定义为其所有字符的反码。我们的任务就是计算出给定字符串的反码。
输入：
    输入每行都是一个字符串，字符串长度不超过 80 个字符。如果输入只有!，表示输入结束，不需要处理。
输出：
对于输入的每个字符串，输出其反码，每个数据占一行。
样例输入：
Hello 
JLU-CCST-2011 
!
样例输出：
Svool 
QOF-XXHG-2011

总结：
在scanf函数中,可以使用　%c来读取一个字符,使用　%s　读取一个字符串，但
是读取字符串时不忽略空格,读字符串时忽略开始的空格,并且读到空格为止,因此只能读取一个单词,
而不是整行字符串，因此一般使用fgets来读取一个字符串。其实scanf函数也可完成这样的功能,而且还更强大。
这里主要介绍一个参数，％[　],这个参数的意义是读入一个字符集合。[　]是个集合的标志,因此%[　]特指读入此集合所限定的那些字符,　
比如　%[A-Z]　是输入大写字母,一旦遇到不在此集合的字符便停止。如果集合的第一个字符是"　^　",　这说明读取不在"　^　"　后面集合的字符,
既遇到"　^　"　后面集合的字符便停止.注意此时读入的字符串是可以含有空格的。



代码如下：
#include<stdio.h>
#include<string.h>
#define MAX 81

char str[MAX];
void Converse(char &item){
	if(item >= 'a' && item <= 'z'){
		item = 'z' - ( item - 'a' );
	}
	else if (item >= 'A' && item <= 'Z'){
		item = 'Z' - ( item - 'A' );
	}
	else{

	}
}
int main()
{
	int n;
	while(gets(str)!=NULL && strcmp(str,"!") != 0){
		if(strlen(str) == 1 && str[0] == '!'){
			return 0;
		}
		for (int i = 0 ; i < strlen(str); i++) {
			Converse(str[i]);
		}
		printf("%s\n",str);
	}
	
	return 0;
}