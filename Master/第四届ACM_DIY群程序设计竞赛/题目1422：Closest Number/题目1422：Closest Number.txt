题目1422：Closest Number

题目描述：
        There is one Master In ACM_DIY called "白衣少年"(White) whose motto is "I can HOLD ANY FEMALE". Since White is really busy with HOLDING FEMALES, he has no idea of the work that is given by his boss(MALE, of course), so can you help him to solve such a simple and really easy problem: 
        Array A has N positive integers,for each A[i] (0<=i<N, indicating the i-th integer in the array A), it fits in a 32-bit signed integer ),find the closest number less than A[i] (if the distance is the same,we prefer the left one).
        If you can solve this problem, White may give you some "tips"(You know better!)
输入：
        T cases (1<=T<=5)
        For each case, the first line give an integer N(1<= N <= 10^6),then the second line has the array with N integers. (All the integers are guaranteed to fit in 32-bit signed integer)
输出：
        For each case, print one line with N space-seperated integers, where the i-th integer is the number who is less that A[i] and is closest to i if exists, otherwise it is 0. 
样例输入：
3
3
2 1 3
3
2 3 1
4
5 7 3 6
样例输出：
1 0 1
1 2 0
3 5 0 3



第一种思路
左边去获取最近的小于他的数 右边获取最近的小于他的数 然后再区分选哪个

代码如下

#include<stdio.h>
#include<string.h>
#define MAX 1000001
#define INVALDIS 1000010

int src[MAX];
int DisLeft[MAX];
int DisRight[MAX];

int main()
{
	int m;
	while(scanf("%d",&m) != EOF) {
		int n;
		for (int i = 0; i < m; i++) {
			scanf("%d",&n);

			//init 
			for (int j = 0; j < n; j++) {
				int tmp ;
				scanf("%d",&tmp);
				src[j] = tmp;
			}


			//left Converse
			for (int j = 0; j < n; j++) {
				if(0 == j){
					DisLeft[j] = INVALDIS;
				}
				else{
					DisLeft[j] = INVALDIS;
					for(int k = j - 1; k >= 0 ; k--){
						if(src[j] > src[k]){
							DisLeft[j] = j - k;
							break;
						}
					}
				}
			}


			//Right Converse
			for (int j = n - 1; j >= 0; j--) {
				if(n-1 == j){
					DisRight[j] = INVALDIS;
				}
				else{
					DisRight[j] = INVALDIS;
					for(int k = j + 1; k <= n  - 1 ; k++){
						if(src[j] > src[k]){
							DisRight[j] = k - j;
							break;
						}
					}
				}
			}

			//print Result
			for (int j = 0; j < n; j++) {
				int index = 0;
				int res;
				if(DisRight[j] == DisLeft[j] && DisLeft[j] == INVALDIS){
					if(0 != j)printf(" ");
					printf("0");
				} else{
					if(DisRight[j] < DisLeft[j]){
						index = j + DisRight[j];
					} else {
						index = j - DisLeft[j];
					}
					if(0 != j)printf(" ");
					printf("%d",src[index]);
				}
			}
			printf("\n");
		}
	}
	return 0;
}

这么做TLE了




